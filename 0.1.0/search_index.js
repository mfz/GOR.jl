var documenterSearchIndex = {"docs":
[{"location":"iterators/#Implementation-of-iterators","page":"Implementation of iterators","title":"Implementation of iterators","text":"","category":"section"},{"location":"iterators/","page":"Implementation of iterators","title":"Implementation of iterators","text":"Iteration protocol implemented through two functions","category":"page"},{"location":"iterators/","page":"Implementation of iterators","title":"Implementation of iterators","text":"ìterate(i)\nìterate(i, s)","category":"page"},{"location":"iterators/","page":"Implementation of iterators","title":"Implementation of iterators","text":"Both functions return (element, state) if data available, otherwise nothing.","category":"page"},{"location":"iterators/","page":"Implementation of iterators","title":"Implementation of iterators","text":"General strategy to implement iterators","category":"page"},{"location":"iterators/","page":"Implementation of iterators","title":"Implementation of iterators","text":"Iterators are implemented as immutable structs. They are parametrized on (at least) input type and output element type.","category":"page"},{"location":"iterators/","page":"Implementation of iterators","title":"Implementation of iterators","text":"struct Iter{I,O}\n       rows::I\nend","category":"page"},{"location":"iterators/","page":"Implementation of iterators","title":"Implementation of iterators","text":"iterate(i::Iter) creates starting state s, and immediately calls iterate(i::Iter, s)","category":"page"},{"location":"iterators/","page":"Implementation of iterators","title":"Implementation of iterators","text":"function iterate(i::Iter)\n\t # prepare state for first iteration\n\t state = ...\n\n\t done? && return nothing\n\t \n\t iterate(i, state)\nend","category":"page"},{"location":"iterators/","page":"Implementation of iterators","title":"Implementation of iterators","text":"function iterate(i::Iter, s)\n\t elt_s, ... = s\n\n\t while true\n\t       # state transitions\n\t \n\t end\nend","category":"page"},{"location":"iterators/","page":"Implementation of iterators","title":"Implementation of iterators","text":"Also implement applicable methods","category":"page"},{"location":"iterators/","page":"Implementation of iterators","title":"Implementation of iterators","text":"Base.IteratorEltype(::Type{Iter})\nBase.eltype(::Type{Iter})\nBase.IteratorSize(::Type{Iter})\nBase.length(i::Iter)\nBase.size(i::Iter)","category":"page"},{"location":"iterators/","page":"Implementation of iterators","title":"Implementation of iterators","text":"To support the Tables.jl interface, also implement","category":"page"},{"location":"iterators/","page":"Implementation of iterators","title":"Implementation of iterators","text":"Tables.istable(i::Iter)\nTables.rowaccess(i::Iter)\nTables.schema(i::Iter)","category":"page"},{"location":"#GorJulia.jl-Documentation","page":"Home","title":"GorJulia.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Purpose","page":"Home","title":"Purpose","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GorJulia is a Julia library to operate on genome ordered streams. Elements of genome ordered streams are sorted by chromosome and position, the first two items of each row element. Streaming allows operations on data sets that are larger than available memory, and genomic order speeds up relational operations like joins.","category":"page"},{"location":"","page":"Home","title":"Home","text":"GorJulia supports the Tables.jl interface. This means it works with all sources and sinks that conform to the Tables.jl interface, e.g.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CSV files,\nSQLite3 tables,\nParquet files,\nand DataFrames,","category":"page"},{"location":"","page":"Home","title":"Home","text":"and are ordered by chromosome and position.","category":"page"},{"location":"","page":"Home","title":"Home","text":"GorJulia allows creation of complex pipelines by joining together operators using the |> syntax. Each operator is implemented as a Julia iterator that is parameterized on input and output types. This allows for easy extension of the library by user-defined operations.","category":"page"},{"location":"#I/O","page":"Home","title":"I/O","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"GorFile(path)\nwrite_gor(rows, path)\n\nGorzFile(path)\n\nParquetFile(path)\nwrite_parquet(rows, path)","category":"page"},{"location":"#GorJulia.GorFile-Tuple{Any}","page":"Home","title":"GorJulia.GorFile","text":"GorFile(path; delim = \"\t\", limit = 10_000, first = nothing, last = nothing)\n\nOpen gor file at path as genome ordered stream.\n\nA gor file is a tab-delimited file with header with first two columns corresponding to Chrom and Pos. The file needs to be sorted by (Chrom, Pos),  using e.g. unix command sort -k1,1 -k2,2n.\n\nArguments\n\npath: path to file\ndelim: file delimiter\nlimit: number of rows to use for type inference\nfirst: first coordinate to report (chrom, pos) or nothing\nlast:  last coordinate to report (chrom, pos) or nothing\n\n\n\n\n\n","category":"method"},{"location":"#GorJulia.write_gor-Tuple{Any,Any}","page":"Home","title":"GorJulia.write_gor","text":"write_gor(rows, path)\nrows |> write_gor(path)\n\nWrite genome ordered stream rows as tab-delimited text file.\n\n\n\n\n\n","category":"method"},{"location":"#GorJulia.GorzFile-Tuple{Any}","page":"Home","title":"GorJulia.GorzFile","text":"GorzFile(path; limit = 10_000, first = nothing, last = nothing)\n\nOpen compressed gor file (.gorz) at path as genome ordered stream.\n\nUse up to limit number of rows for type inference. \n\n\n\n\n\n","category":"method"},{"location":"#GorJulia.ParquetFile-Tuple{Any}","page":"Home","title":"GorJulia.ParquetFile","text":"ParquetFile(path)\n\nOpen Parquet file at path as genome ordered stream.\n\nThis uses implementation in Parquet.jl, which is not very mature yet. Iterator struct contains state, so best to use  data = () -> ParquetFile(\"data.parquet\"). \n\n\n\n\n\n","category":"method"},{"location":"#GorJulia.write_parquet-Tuple{Any,Any}","page":"Home","title":"GorJulia.write_parquet","text":"write_parquet(rows, path)\nrows |> write_parquet(path)\n\nWrite genome ordered stream rows as Parquet file to path.\n\n\n\n\n\n","category":"method"},{"location":"#Operations-on-streams","page":"Home","title":"Operations on streams","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"verifyorder(rows)\nGorJulia.select(rows, columns::Symbol...)\nGorJulia.gorfilter(rows, predicate)\nGorJulia.rename(rows, args::Pair...)\nGorJulia.mutate(rows, columns::Tuple, func)\n\ngormerge(left, right)\ngormap(rows, func)\n\ngorjoin(left, right)","category":"page"},{"location":"#GorJulia.verifyorder-Tuple{Any}","page":"Home","title":"GorJulia.verifyorder","text":"verifyorder(rows)\nrows |> verifyorder\n\nVerify order of genome ordered stream rows.\n\nAn iterator that checks if its input is ordered by (elt[1], elt[2]). The iterator passes the input rows through, but throws an ErrorException if rows are out of order.  \n\n\n\n\n\n","category":"method"},{"location":"#GorJulia.select-Tuple{Any,Vararg{Symbol,N} where N}","page":"Home","title":"GorJulia.select","text":"select(rows, columns::Symbol...)\nrows |> select(columns::Symbol...)\n\nSelect columns from genome ordered stream rows. \n\n\n\n\n\n","category":"method"},{"location":"#GorJulia.gorfilter-Tuple{Any,Any}","page":"Home","title":"GorJulia.gorfilter","text":"gorfilter(rows, predicate)\nrows |> gorfilter(predicate)\n\nFilter rows to include only rows that fulfil predicate.\n\n\n\n\n\n","category":"method"},{"location":"#GorJulia.rename-Tuple{Any,Vararg{Pair,N} where N}","page":"Home","title":"GorJulia.rename","text":"rename(rows, args::Pair...)\nrows |> rename(args::Pairs...)\n\nRename columns in genome ordered stream rows.  Old and new column names are specified as :oldcol => :newcol.\n\n\n\n\n\n","category":"method"},{"location":"#GorJulia.mutate-Tuple{Any,Tuple,Any}","page":"Home","title":"GorJulia.mutate","text":"mutate(rows, cols::Tuple, func)\nmutate(rows, col::Symbol, func)\nrows |> mutate(cols::Tuple, func)\nrows |> mutate(col::Symbol, func)\n\nAdd or replace columns cols computed as cols = func(row) to genome ordered stream rows.\n\n\n\n\n\n","category":"method"},{"location":"#GorJulia.gormerge-Tuple{Any,Any}","page":"Home","title":"GorJulia.gormerge","text":"gormerge(left, right)\nleft |> gormerge(right)\n\nMerge left and right genome ordered streams.\n\nOutput stream contains union of columns with type promotion\n\n\n\n\n\n","category":"method"},{"location":"#GorJulia.gormap-Tuple{Any,Any}","page":"Home","title":"GorJulia.gormap","text":"gormap(rows, func)\nrows |> gormap(func)\n\nApply function func to elements of genome ordered stream rows. The function func should return a NamedTuple.\n\nNOTE: Julia cannot infer the type of NamedTuples with Union{Missing,T}. This means that if the input stream rows has columns of type Union{Missing,T}, the pipeline probably fails. \n\n\n\n\n\n","category":"method"},{"location":"#GorJulia.gorjoin-Tuple{Any,Any}","page":"Home","title":"GorJulia.gorjoin","text":"gorjoin(left, right; kind = :snpsnp, leftjoin = false, window = 0)\n\nleft |> gorjoin(right; kind = :snpsnp, leftjoin = false, window = 0)\n\nJoin genome ordered streams left and right on (elt[1], elt[2]).\n\nArguments\n\nleftjoin::Bool: should left join be performed\nkind::Symbol: how should overlap be determined (:snpsnp, :snpseg, :segsnp, :segseg)\nwindow::Int: allow window base pairs difference in position   \n\n\n\n\n\n","category":"method"},{"location":"#Grouping","page":"Home","title":"Grouping","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"groupby(n=0, groupcols = []; aggregates...)","category":"page"},{"location":"#GorJulia.groupby","page":"Home","title":"GorJulia.groupby","text":"rows |> groupby(n=0, groupcols = []; aggregates...)\n\nGroup genome ordered stream by position window and groupcols. Summarize groups using aggregates.\n\nFor each window and combination of grouping columns, compute the online-statistics specified.\n\nArguments\n\nn::Int : group by window of size n, genomewide for n=0\ngroupcols::Vector{Symbol}: additional grouping columns\naggregates : online statistics to compute \n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"Currently the following aggregators are implemented. See OnlineStats.jl for more ideas.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Sum(column::Symbol, val = 0.0)\nCount\nAvg(column::Symbol)","category":"page"},{"location":"#GorJulia.Sum","page":"Home","title":"GorJulia.Sum","text":"Sum(column::Symbol, val = 0.0)\n\nAggregator for sum of column. \n\n\n\n\n\n","category":"type"},{"location":"#GorJulia.Count","page":"Home","title":"GorJulia.Count","text":"Count()\n\nAggregator for count.\n\n\n\n\n\n","category":"type"},{"location":"#GorJulia.Avg-Tuple{Symbol}","page":"Home","title":"GorJulia.Avg","text":"Avg(column::Symbol)\n\nAggregator for average of column.\n\n\n\n\n\n","category":"method"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
